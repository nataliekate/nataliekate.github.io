{"data":{"site":{"siteMetadata":{"title":"Natalie's Blog","author":"nataliekate"}},"markdownRemark":{"id":"afe916c4-81a1-53de-aab1-d4c0c80f3272","excerpt":"同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation…","html":"<p>同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为<strong>内容协商（Content Negotiation）</strong></p>\n<p><strong>内容协商机制</strong>是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的<em>语言、字符集、编码方式</em>等作为判断的基准。通过这个机制，单一的URL可以代表不同的资源（比如一个网站网页的法语版和英语版）。这些不同的版本称为<strong>变体（variants）</strong>。</p>\n<p>HTTP提供了多种内容协商机制：<strong>服务器驱动</strong>（或称主动（proactive））、<strong>客户端驱动/用户代理驱动</strong>（或称被动（reactive））、<strong>透明（前两者的结合）</strong>。</p>\n<h2>1. 客户端驱动（Client-Driven）/用户代理驱动（Agent-Driven）</h2>\n<h3>实现原理</h3>\n<p>服务器由两种方法为客户端提供选项：</p>\n<ul>\n<li>发送回一个HTML文档，里面由该页面的各种版本的链接和每个版本的描述信息</li>\n<li>发送回HTTP/1.1的 <code class=\"language-text\">300 Multiple Choices</code> 响应代码</li>\n</ul>\n<p><img src=\"https://mdn.mozillademos.org/files/13795/HTTPNego3.png\" alt=\"client-driven negotiation image\"></p>\n<p>这种机制下，决定是由客户端用户作出的。</p>\n<h3>缺点</h3>\n<p>这种机制的不利之处在于：</p>\n<ul>\n<li>每个页面都需要两次请求，第一次获取列表，第二次获取选择的副本。这样会减慢内容呈现的速度。</li>\n<li>此外，它还需要多个URL：公共页面要一个，其他每种特殊页面也都要一个。</li>\n</ul>\n<h2>2. 服务器驱动（Server-Driven）</h2>\n<p>减少额外通信量的一种方法是让服务器来决定返回哪个页面，但为了做到这一点，客户端需要提供足够的客户偏好信息，以便服务器能准确地作出决策。而这些信息是通过 <strong>客户端请求的首部（client’s request headers）</strong> 来获取的。</p>\n<blockquote>\n<p>These headers describe the preferred choice of the user. The server uses them as hints and an internal algorithm chooses the best content to serve to the client. The algorithm is <em>server-specific</em> and not defined in the standard. (<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#Server-driven_content_negotiation\">MDN</a>)</p>\n</blockquote>\n<p><img src=\"https://mdn.mozillademos.org/files/13791/HTTPNegoServer.png\" alt=\"server-driven negotiation image\"></p>\n<p>HTTP服务器发送响应的评估机制有以下这些：</p>\n<ul>\n<li>检查内容协商首部（content-negotiation headers）</li>\n<li>根据其他（非内容协商）首部进行变通：如<code class=\"language-text\">User Agent</code></li>\n<li>客户端提示（client hints）：目前还是实验性提案（<a href=\"https://httpwg.org/http-extensions/client-hints.html\">HTTP Client Hints - Working Group</a>，  <a href=\"https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints\">Automating Resource Selection with Client Hints - Google Developers</a> ）</li>\n</ul>\n<h3>内容协商首部集</h3>\n<table>\n<thead>\n<tr>\n<th>首部名称</th>\n<th>描述</th>\n<th>对应的实体首部（entity header）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Accept</code></td>\n<td>告知服务器发送何种媒体类型</td>\n<td><code class=\"language-text\">Content-Type</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Accept-Charset</code></td>\n<td>告知服务器发送何种字符集</td>\n<td><code class=\"language-text\">Content-Type</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Accept-Encoding</code></td>\n<td>告知服务器采用何种编码</td>\n<td><code class=\"language-text\">Content-Encoding</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Accept-Language</code></td>\n<td>告知服务器发送何种语言</td>\n<td><code class=\"language-text\">Content-Language</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>内容协商首部集有对应的实体首部集，这里实体首部集描述了把报文<strong>从服务器端传输给客户端</strong>的过程中必须的各种报文主体（message body）属性，而内容协商首部集是<strong>由客户端发送给服务器端</strong>用于交换偏好信息的，以便服务器端可以选择出最符合客户偏好的版本。</p>\n</blockquote>\n<blockquote>\n<p>由于HTTP是<strong>无状态的（stateless）</strong>，服务器端不会在不同请求之间追踪客户端的偏好，因此客户端必须在每个请求中都发送其偏好信息。</p>\n</blockquote>\n<h4>质量值（Quality Values，简称 <code class=\"language-text\">q</code> 值）</h4>\n<p>假设某个客户偏好西班牙语，服务器端只有英语和法语两个版本的页面，此时服务器需要一种机制来确定客户偏好的优先次序。这种机制就叫做<strong>质量值</strong>，简称 <code class=\"language-text\">q</code> 值（qvalue）。</p>\n<p><code class=\"language-text\">q</code> 值的范围为 0 - 1 间的实数，0.001为优先级最低，1为优先级最高；0代表 “Not Acceptable”。如果没有定义 <code class=\"language-text\">q</code> 值，则默认为1。</p>\n<p>例如</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Accept-Language: en;q=0.5, fr;q=0.001, nl;q=1.0, tr;q=0.0</code></pre></div>\n<h3>随其他首部变化</h3>\n<p>服务器端也可根据其他客户端请求首部来匹配响应。在这种情况下，服务器端返回什么取决于其实现方式。</p>\n<p>比如 <code class=\"language-text\">User-Agent</code> 例如有些浏览器不支持JavaScript，就可以向其发送不含有JavaScript的页面版本，不过这种做法不提倡使用。</p>\n<p>响应中通常会发送 <code class=\"language-text\">Vary</code> 首部，来说明实际上哪些消息头被用作内容协商的参考依据（确切来说是与之相关的响应消息头），这样可以使缓存的运作更有效。</p>\n<h4><code class=\"language-text\">Vary</code> 用于动态服务</h4>\n<p><code class=\"language-text\">Vary</code> 是一个HTTP响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复。</p>\n<p>与前面列举的 <code class=\"language-text\">Accept-*</code> 形式的由客户端发送的首部相反，<code class=\"language-text\">Vary</code> 首部是由服务器在响应中发送的。它标示了服务器在服务端驱动型内容协商阶段所使用的首部清单。这个首部是必要的，它可以用来通知缓存服务器决策的依据，这样它可以进行复现，使得缓存服务器在预防将错误内容提供给用户方面发挥作用。</p>\n<blockquote>\n<p>When using the <code class=\"language-text\">Vary: User-Agent</code> header, caching servers should consider the user agent when deciding whether to serve the page from cache.\nFor example, if you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users.\nIt can help Google and other search engines to discover the mobile version of a page, and might also tell them that no Cloaking is intended.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Vary: User-Agent</code></pre></div>\n<h3>服务器端扩展</h3>\n<p>另一种在服务器端实现内容协商的方法是使用服务器端扩展，比如微软的<a href=\"https://en.wikipedia.org/wiki/ASP.NET\">ASP.NET</a></p>\n<h3>缺点</h3>\n<p>Proactive negotiation has serious disadvantages:</p>\n<ul>\n<li>\n<p>服务器对浏览器并非全知全能。即便是有了客户端示意扩展，也依然无法获取关于浏览器能力的全部信息。与客户端进行选择的代理驱动型内容协商机制不同，服务器端的选择总是显得有点武断。</p>\n<blockquote>\n<p>It is <strong>impossible</strong> for the server to accurately determine what might be <strong>“best”</strong> for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?); </p>\n</blockquote>\n</li>\n<li>\n<p>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）。</p>\n<blockquote>\n<p>Having the user agent describe its capabilities in every request can be both very <strong>inefficient</strong> (given that only a small percentage\nof responses have multiple representations) (<a href=\"https://tools.ietf.org/html/rfc7541\">HTTP/2 header compression</a> mitigates this problem)  and a potential risk to the user’s privacy (<a href=\"http://www.net-square.com/httprint_paper.html\">HTTP fingerprinting</a>);</p>\n</blockquote>\n</li>\n<li>\n<p>因为给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</p>\n<blockquote>\n<p>It complicates the implementation of an origin server and the algorithms for generating responses to a request; and, <br> It limits the reusability of responses for shared caching (several representations of a given resource are sent)</p>\n</blockquote>\n</li>\n</ul>\n<h2>3. 透明（Transparent）</h2>\n<p>透明协商机制试图减轻服务器驱动协商中服务器的负载，并用<strong>中间代理</strong>来代表客户端，以使与客户端的报文交换最小化。\n<br>\n假定代理了解客户端的预期，这样就可以代表客户端与服务器协商。\n<br>\n服务器必须有能力告知代理，需要检查哪些请求首部（request headers），以便进行最佳匹配。</p>\n<h3>代理缓存（Caching Proxies）</h3>\n<p>代理缓存可以为通过单个URL访问的文档保存不同的副本，这些不同的版本称为 <em>变体（variant）</em> 或者 <em>备用候选（alternate）</em> 。服务器把它们的决策逻辑、<code class=\"language-text\">Accept</code> 首部集等传给缓存，这样代理就可以代表服务器与客户端进行协商。同时缓存也可以对内容进行转码。</p>\n<h3>使用 <code class=\"language-text\">Vary</code> 首部</h3>\n<p>HTTP/1.1定义了 <code class=\"language-text\">Vary</code> 首部。服务器在响应中发送 <code class=\"language-text\">Vary</code> 首部，以告知中间节点需要使用哪些请求首部进行内容协商。<br>\n在之前提到的代理缓存中，如果服务器的决策依据不是 <code class=\"language-text\">Accept</code> 首部集，而是其他（如 <code class=\"language-text\">User-Agent</code> ）的话，缓存必须知道这些首部是什么，这样才能作出正确的判断。例如，所提供的文档取决于 <code class=\"language-text\">User-Agent</code> ，<code class=\"language-text\">Vary</code> 首部就必须包括 <code class=\"language-text\">User-Agent</code> <br></p>\n<p>当新的请求到达时，缓存会根据 <code class=\"language-text\">Accept-*</code> 首部集来寻找最佳匹配。然而在把文档提供给客户端之前，它必须检查服务器端有没有在<strong>已缓存响应</strong>中发送过 <code class=\"language-text\">Vary</code> 首部。如果有，则新请求中的那些首部的值必须与<strong>已缓存请求</strong>里对应的首部相同。如果无法匹配，则从服务器获取文档。</p>\n<hr>\n<p>参考链接：\n<br>\n<a href=\"https://tools.ietf.org/html/rfc7231#section-5.3\">RFC 7231 - 5.3. Content Negotiation</a>\n<br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation\">Content negotiation - HTTP | MDN</a></p>","frontmatter":{"title":"什么是内容协商？","date":"May 20, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/content-negotiation/","previous":{"fields":{"slug":"/message_vs_entity/"},"frontmatter":{"title":"HTTP Message vs. HTTP Entity"}},"next":null}}